/**
 * Video Info Service
 * Handles extracting video information from URLs using yt-dlp
 */

import {
  spawnYtDlp,
  isBinaryAvailable,
  ensureYtDlp,
} from "../../utils/binary-manager";
import {
  VideoInfo,
  VideoFormat,
  Thumbnail,
  SubtitleTrack,
  PlaylistInfo,
  PlaylistVideoEntry,
  ApiResponse,
  SUPPORTED_PLATFORMS,
  PlatformInfo,
} from "../types";

/**
 * Raw yt-dlp format object
 */
interface YtDlpFormat {
  format_id: string;
  ext: string;
  resolution?: string;
  format_note?: string;
  filesize?: number;
  filesize_approx?: number;
  fps?: number;
  vcodec?: string;
  acodec?: string;
  tbr?: number;
  height?: number;
  width?: number;
}

/**
 * Raw yt-dlp info JSON structure
 */
interface YtDlpInfo {
  id: string;
  title: string;
  description?: string;
  duration?: number;
  duration_string?: string;
  uploader?: string;
  uploader_url?: string;
  upload_date?: string;
  view_count?: number;
  like_count?: number;
  thumbnail?: string;
  thumbnails?: Array<{
    url: string;
    width?: number;
    height?: number;
    resolution?: string;
  }>;
  formats?: YtDlpFormat[];
  subtitles?: Record<string, Array<{ url: string; ext: string }>>;
  automatic_captions?: Record<string, Array<{ url: string; ext: string }>>;
  webpage_url: string;
  extractor: string;
  extractor_key: string;
  is_live?: boolean;
  _type?: string;
  entries?: YtDlpInfo[];
  playlist_count?: number;
  playlist_title?: string;
}

/**
 * Parse yt-dlp format to our VideoFormat type
 */
function parseFormat(format: YtDlpFormat): VideoFormat {
  const hasVideo = format.vcodec !== "none" && format.vcodec !== null;
  const hasAudio = format.acodec !== "none" && format.acodec !== null;

  let resolution: string | null = null;
  if (format.height) {
    resolution = `${format.height}p`;
  } else if (format.resolution) {
    resolution = format.resolution;
  }

  let quality = format.format_note || "";
  if (!quality && resolution) {
    quality = resolution;
  }

  return {
    formatId: format.format_id,
    extension: format.ext || "unknown",
    resolution,
    quality,
    filesize: format.filesize || null,
    filesizeApprox: format.filesize_approx || null,
    fps: format.fps || null,
    vcodec: format.vcodec || null,
    acodec: format.acodec || null,
    hasVideo,
    hasAudio,
    tbr: format.tbr || null,
  };
}

/**
 * Parse subtitles from yt-dlp response
 */
function parseSubtitles(
  subtitles?: Record<string, Array<{ url: string; ext: string }>>,
  autoCaptions?: Record<string, Array<{ url: string; ext: string }>>
): Record<string, SubtitleTrack[]> {
  const result: Record<string, SubtitleTrack[]> = {};

  // Regular subtitles
  if (subtitles) {
    for (const [lang, tracks] of Object.entries(subtitles)) {
      result[lang] = tracks.map((track) => ({
        language: lang,
        languageCode: lang,
        url: track.url,
        ext: track.ext,
        isAutoGenerated: false,
      }));
    }
  }

  // Auto-generated captions
  if (autoCaptions) {
    for (const [lang, tracks] of Object.entries(autoCaptions)) {
      const existing = result[lang] || [];
      result[lang] = [
        ...existing,
        ...tracks.map((track) => ({
          language: lang,
          languageCode: lang,
          url: track.url,
          ext: track.ext,
          isAutoGenerated: true,
        })),
      ];
    }
  }

  return result;
}

/**
 * Parse yt-dlp info JSON to our VideoInfo type
 */
function parseVideoInfo(info: YtDlpInfo): VideoInfo {
  const thumbnails: Thumbnail[] = (info.thumbnails || []).map((t) => ({
    url: t.url,
    width: t.width,
    height: t.height,
    resolution: t.resolution,
  }));

  const formats: VideoFormat[] = (info.formats || []).map(parseFormat);

  // Sort formats by quality (highest first)
  formats.sort((a, b) => {
    const resA = parseInt(a.resolution?.replace("p", "") || "0");
    const resB = parseInt(b.resolution?.replace("p", "") || "0");
    return resB - resA;
  });

  const subtitles = parseSubtitles(info.subtitles, info.automatic_captions);

  // Check if this is a playlist
  const isPlaylist = info._type === "playlist" && Array.isArray(info.entries);

  let playlist: PlaylistInfo | undefined;
  if (isPlaylist && info.entries) {
    playlist = {
      id: info.id,
      title: info.playlist_title || info.title,
      description: info.description || null,
      uploader: info.uploader || null,
      uploaderUrl: info.uploader_url || null,
      thumbnail: info.thumbnail || null,
      videoCount: info.playlist_count || info.entries.length,
      videos: info.entries.map((entry, index) => ({
        id: entry.id,
        title: entry.title,
        duration: entry.duration || null,
        thumbnail: entry.thumbnail || null,
        url: entry.webpage_url,
        index: index + 1,
      })),
    };
  }

  return {
    id: info.id,
    title: info.title,
    description: info.description || null,
    duration: info.duration || null,
    durationString: info.duration_string || null,
    uploader: info.uploader || null,
    uploaderUrl: info.uploader_url || null,
    uploadDate: info.upload_date || null,
    viewCount: info.view_count || null,
    likeCount: info.like_count || null,
    thumbnail:
      info.thumbnail ||
      (thumbnails.length > 0 ? thumbnails[thumbnails.length - 1].url : null),
    thumbnails,
    formats,
    subtitles,
    webpage_url: info.webpage_url,
    extractor: info.extractor,
    extractorKey: info.extractor_key,
    isLive: info.is_live || false,
    isPlaylist,
    playlist,
  };
}

/**
 * Extract video information from a URL
 */
export async function extractVideoInfo(
  url: string
): Promise<ApiResponse<VideoInfo>> {
  // Ensure yt-dlp is available
  if (!isBinaryAvailable()) {
    try {
      await ensureYtDlp();
    } catch (error) {
      return {
        success: false,
        error:
          "yt-dlp is not available. Please check your internet connection.",
      };
    }
  }

  return new Promise((resolve) => {
    const args = [
      "--dump-json",
      "--no-download",
      "--no-playlist", // Get single video info, not entire playlist
      "--flat-playlist", // Quick info for playlists
      "--no-warnings",
      "-q",
      url,
    ];

    const process = spawnYtDlp(args);
    let stdout = "";
    let stderr = "";

    process.stdout?.on("data", (data) => {
      stdout += data.toString();
    });

    process.stderr?.on("data", (data) => {
      stderr += data.toString();
    });

    process.on("close", (code) => {
      if (code !== 0 || !stdout) {
        resolve({
          success: false,
          error: stderr || "Failed to extract video information",
        });
        return;
      }

      try {
        const info = JSON.parse(stdout) as YtDlpInfo;
        const videoInfo = parseVideoInfo(info);

        resolve({
          success: true,
          data: videoInfo,
        });
      } catch (parseError) {
        resolve({
          success: false,
          error: "Failed to parse video information",
        });
      }
    });

    process.on("error", (error) => {
      resolve({
        success: false,
        error: `Process error: ${error.message}`,
      });
    });
  });
}

/**
 * Extract playlist information from a URL
 */
export async function extractPlaylistInfo(
  url: string
): Promise<ApiResponse<PlaylistInfo>> {
  if (!isBinaryAvailable()) {
    try {
      await ensureYtDlp();
    } catch (error) {
      return {
        success: false,
        error: "yt-dlp is not available.",
      };
    }
  }

  return new Promise((resolve) => {
    const args = [
      "--dump-json",
      "--no-download",
      "--flat-playlist", // Get playlist entries quickly
      "--no-warnings",
      "-q",
      url,
    ];

    const process = spawnYtDlp(args);
    let stdout = "";
    let stderr = "";

    process.stdout?.on("data", (data) => {
      stdout += data.toString();
    });

    process.stderr?.on("data", (data) => {
      stderr += data.toString();
    });

    process.on("close", (code) => {
      if (code !== 0 || !stdout) {
        resolve({
          success: false,
          error: stderr || "Failed to extract playlist information",
        });
        return;
      }

      try {
        // yt-dlp outputs each playlist entry as a separate JSON line
        const lines = stdout.trim().split("\n");
        const entries: PlaylistVideoEntry[] = [];

        for (let i = 0; i < lines.length; i++) {
          const entry = JSON.parse(lines[i]) as YtDlpInfo;
          entries.push({
            id: entry.id,
            title: entry.title,
            duration: entry.duration || null,
            thumbnail: entry.thumbnail || null,
            url: entry.webpage_url,
            index: i + 1,
          });
        }

        // Get first entry for playlist metadata
        const firstEntry = JSON.parse(lines[0]) as YtDlpInfo;

        const playlistInfo: PlaylistInfo = {
          id: firstEntry.id,
          title: "Playlist",
          description: null,
          uploader: firstEntry.uploader || null,
          uploaderUrl: firstEntry.uploader_url || null,
          thumbnail: entries[0]?.thumbnail || null,
          videoCount: entries.length,
          videos: entries,
        };

        resolve({
          success: true,
          data: playlistInfo,
        });
      } catch (parseError) {
        resolve({
          success: false,
          error: "Failed to parse playlist information",
        });
      }
    });

    process.on("error", (error) => {
      resolve({
        success: false,
        error: `Process error: ${error.message}`,
      });
    });
  });
}

/**
 * Detect the platform from a URL
 */
export function detectPlatform(url: string): PlatformInfo | null {
  try {
    const urlObj = new URL(url);
    const hostname = urlObj.hostname.toLowerCase().replace("www.", "");

    for (const [key, platform] of Object.entries(SUPPORTED_PLATFORMS)) {
      if (platform.domains.some((domain) => hostname.includes(domain))) {
        return platform;
      }
    }

    return null;
  } catch {
    return null;
  }
}

/**
 * Check if a URL is supported by yt-dlp
 */
export async function isUrlSupported(url: string): Promise<boolean> {
  if (!isBinaryAvailable()) {
    return false;
  }

  return new Promise((resolve) => {
    const args = ["--simulate", "--no-download", "--quiet", url];

    const process = spawnYtDlp(args);

    process.on("close", (code) => {
      resolve(code === 0);
    });

    process.on("error", () => {
      resolve(false);
    });
  });
}

/**
 * Get available formats for a video
 */
export async function getAvailableFormats(
  url: string
): Promise<ApiResponse<VideoFormat[]>> {
  const infoResult = await extractVideoInfo(url);

  if (!infoResult.success || !infoResult.data) {
    return {
      success: false,
      error: infoResult.error || "Failed to get video formats",
    };
  }

  return {
    success: true,
    data: infoResult.data.formats,
  };
}

/**
 * Get best available quality for a video
 */
export function getBestQuality(formats: VideoFormat[]): VideoFormat | null {
  // Filter for formats with both video and audio, or video only
  const videoFormats = formats.filter((f) => f.hasVideo);

  if (videoFormats.length === 0) {
    return null;
  }

  // Sort by resolution (highest first)
  videoFormats.sort((a, b) => {
    const resA = parseInt(a.resolution?.replace("p", "") || "0");
    const resB = parseInt(b.resolution?.replace("p", "") || "0");
    return resB - resA;
  });

  return videoFormats[0];
}

/**
 * Get formats grouped by quality
 */
export function groupFormatsByQuality(
  formats: VideoFormat[]
): Record<string, VideoFormat[]> {
  const groups: Record<string, VideoFormat[]> = {};

  for (const format of formats) {
    const quality = format.resolution || "Other";
    if (!groups[quality]) {
      groups[quality] = [];
    }
    groups[quality].push(format);
  }

  return groups;
}
