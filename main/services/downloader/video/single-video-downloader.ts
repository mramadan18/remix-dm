import { BaseDownloader } from "./base-downloader";
import {
  DownloadOptions,
  VideoInfo,
  DownloadQuality,
  VideoFormat,
  ApiResponse,
  SubtitleTrack,
  QualityOption,
} from "../types";
import {
  getYtDlpWrap,
  getFfmpegPath,
  isFfmpegAvailable,
  ensureYtDlp,
} from "../../utils/binary-manager";
import { settingsService } from "../../settings.service";

export class SingleVideoDownloader extends BaseDownloader {
  /**
   * Get single video metadata
   */
  async getVideoMetadata(
    url: string,
    isPlaylist: boolean = false,
  ): Promise<ApiResponse<VideoInfo>> {
    try {
      await ensureYtDlp();
      const ytDlp = getYtDlpWrap();

      const args = [
        url,
        "--dump-single-json",
        "--no-warnings",
        "--no-check-certificates",
      ];

      if (isPlaylist) {
        args.push("--flat-playlist");
      }

      const rawOutput = await ytDlp.execPromise(args);
      const metadata = JSON.parse(rawOutput);

      const videoInfo: VideoInfo = {
        id: metadata.id,
        title: metadata.title,
        description: metadata.description || null,
        duration: metadata.duration || null,
        durationString: metadata.duration_string || null,
        uploader: metadata.uploader || null,
        uploaderUrl: metadata.uploader_url || null,
        uploadDate: metadata.upload_date || null,
        viewCount: metadata.view_count || null,
        likeCount: metadata.like_count || null,
        thumbnail: metadata.thumbnail || null,
        thumbnails: (metadata.thumbnails || []).map((t: any) => ({
          url: t.url,
          width: t.width,
          height: t.height,
          resolution: t.resolution,
        })),
        formats: (metadata.formats || []).map((f: any) => ({
          formatId: f.format_id,
          extension: f.ext,
          resolution: f.resolution || null,
          quality: f.quality ? String(f.quality) : "",
          filesize: f.filesize || null,
          filesizeApprox: f.filesize_approx || null,
          fps: f.fps || null,
          vcodec: f.vcodec || null,
          acodec: f.acodec || null,
          hasVideo: f.vcodec !== "none",
          hasAudio: f.acodec !== "none",
          tbr: f.tbr || null,
          protocol: f.protocol || null,
        })),
        subtitles: this.mapSubtitles(metadata.subtitles),
        webpage_url: metadata.webpage_url,
        extractor: metadata.extractor,
        extractorKey: metadata.extractor_key,
        isLive: metadata.is_live || false,
        isPlaylist: !!metadata._type && metadata._type === "playlist",
      };

      videoInfo.qualityOptions = this.processQualityOptions(
        videoInfo.formats,
        videoInfo.duration,
      );

      return { success: true, data: videoInfo };
    } catch (error) {
      return {
        success: false,
        error:
          error instanceof Error ? error.message : "Failed to fetch metadata",
      };
    }
  }

  private mapSubtitles(subs: any): Record<string, SubtitleTrack[]> {
    if (!subs) return {};
    const result: Record<string, SubtitleTrack[]> = {};
    for (const lang in subs) {
      result[lang] = subs[lang].map((s: any) => ({
        language: lang,
        languageCode: lang,
        url: s.url,
        ext: s.ext,
        isAutoGenerated: false,
      }));
    }
    return result;
  }

  /**
   * Process and group formats into clean quality options with accurate size estimation
   */
  public processQualityOptions(
    formats: VideoFormat[],
    duration: number | null,
  ): QualityOption[] {
    // Helper to check if format is HLS (unreliable format)
    const isHLS = (f: VideoFormat) => {
      return (
        f.protocol === "m3u8_native" ||
        f.protocol === "m3u8" ||
        f.extension === "m3u8"
      );
    };

    const videoOnly = formats.filter(
      (f) => f.hasVideo && !f.hasAudio && !isHLS(f),
    );
    const audioOnly = formats.filter(
      (f) => f.hasAudio && !f.hasVideo && !isHLS(f),
    );
    const combined = formats.filter(
      (f) => f.hasVideo && f.hasAudio && !isHLS(f),
    );

    const bestAudio = [...audioOnly].sort((a, b) => {
      const getAudioScore = (f: VideoFormat) => {
        const ext = (f.extension || "").toLowerCase();
        if (ext === "webm") return 3;
        if (ext === "m4a") return 2;
        return 1;
      };
      const scoreA = getAudioScore(a);
      const scoreB = getAudioScore(b);
      if (scoreA !== scoreB) return scoreB - scoreA;
      return (b.tbr || 0) - (a.tbr || 0);
    })[0];

    const audioSize = bestAudio
      ? this.calculateFormatSize(bestAudio, duration) || 0
      : 0;

    const groups = new Map<number, VideoFormat[]>();
    [...videoOnly, ...combined].forEach((f) => {
      const height = this.getHeightFromFormat(f);
      if (!height) return;
      if (!groups.has(height)) groups.set(height, []);
      groups.get(height)!.push(f);
    });

    const options: QualityOption[] = [];

    groups.forEach((formatsInGroup, height) => {
      const combinedFormats = formatsInGroup.filter((f) => f.hasAudio);
      const videoOnlyFormats = formatsInGroup.filter((f) => !f.hasAudio);
      const formatsToSort =
        combinedFormats.length > 0 ? combinedFormats : videoOnlyFormats;

      const bestVideo = formatsToSort.sort((a, b) => {
        const getCodecScore = (f: VideoFormat) => {
          const vcodec = (f.vcodec || "").toLowerCase();
          if (vcodec.includes("av01")) return 3;
          if (vcodec.includes("vp9") || vcodec.includes("vp09")) return 2;
          if (vcodec.includes("avc") || vcodec.includes("h264")) return 1;
          return 0;
        };
        const scoreA = getCodecScore(a);
        const scoreB = getCodecScore(b);
        if (scoreA !== scoreB) return scoreB - scoreA;
        if ((b.fps || 0) !== (a.fps || 0)) return (b.fps || 0) - (a.fps || 0);
        return (b.tbr || 0) - (a.tbr || 0);
      })[0];

      const videoSize = this.calculateFormatSize(bestVideo, duration) || 0;
      const totalSize = bestVideo.hasAudio ? videoSize : videoSize + audioSize;

      options.push({
        key: `${height}p`,
        label: this.getQualityLabel(height),
        quality: `${height}p`,
        resolution: bestVideo.resolution || `${height}p`,
        totalSize: totalSize > 0 ? totalSize : null,
        videoFormat: bestVideo,
        audioFormat: bestVideo.hasAudio ? undefined : bestAudio,
      });
    });

    if (bestAudio) {
      options.push({
        key: "bestaudio",
        label: "Audio Only",
        quality: "audio",
        resolution: "audio",
        totalSize: audioSize > 0 ? audioSize : null,
        audioFormat: bestAudio,
      });
    }

    return options.sort((a, b) => {
      const getRes = (key: string) => parseInt(key) || 0;
      const resA = getRes(a.key);
      const resB = getRes(b.key);
      if (resA !== resB) return resB - resA;
      return a.key === "bestaudio" ? 1 : -1;
    });
  }

  private calculateFormatSize(
    format: VideoFormat,
    duration: number | null,
  ): number | null {
    if (format.filesize) return format.filesize;
    if (format.filesizeApprox) return format.filesizeApprox;
    if (format.tbr && duration) {
      return Math.round((format.tbr * 1024 * duration) / 8);
    }
    return null;
  }

  private getQualityLabel(height: number): string {
    if (height >= 2160) return "4K (2160p)";
    if (height >= 1440) return "2K (1440p)";
    if (height >= 1080) return "Full HD (1080p)";
    if (height >= 720) return "HD (720p)";
    if (height >= 480) return "SD (480p)";
    if (height >= 360) return "Low (360p)";
    return `${height}p`;
  }

  /**
   * Build yt-dlp arguments for single video download
   */
  public buildArgs(
    options: DownloadOptions,
    outputFilePath: string,
    videoInfo?: VideoInfo | null,
  ): string[] {
    const args = this.getBaseArgs();

    args.push("-o", outputFilePath);

    // Windows solutions
    if (options.isPlaylist) {
      // Specific fixes for playlist items on Windows
      args.push("--no-part"); // Prevents WinError 32
      args.push("--trim-filenames", "160"); // Avoids long path issues
    } else {
      args.push("--no-playlist");
      args.push("--trim-filenames", "160");
    }

    args.push("--windows-filenames");

    const settings = settingsService.getSettings();
    if (settings.onFileExists === "skip") {
      args.push("--no-overwrites");
    } else if (settings.onFileExists === "overwrite") {
      args.push("--force-overwrites");
    } else if (settings.onFileExists === "rename") {
      args.push("--no-overwrites");
    }

    // Prevents issues with existing files on Windows
    args.push("--no-mtime");

    const ffmpegLocation = getFfmpegPath();
    if (ffmpegLocation && isFfmpegAvailable()) {
      args.push("--ffmpeg-location", ffmpegLocation);
    }

    // Quality/Format selection
    if (options.audioOnly) {
      let formatSelector =
        "bestaudio[ext=m4a][protocol!=m3u8_native]/bestaudio[ext=webm][protocol!=m3u8_native]/bestaudio/best";
      if (videoInfo?.qualityOptions) {
        const audioOpt = videoInfo.qualityOptions.find(
          (opt) => opt.key === "bestaudio",
        );
        if (audioOpt?.audioFormat?.formatId) {
          formatSelector = `${audioOpt.audioFormat.formatId}/${formatSelector}`;
        }
      }
      args.push("-f", formatSelector);
      args.push("-x");
      if (options.format) {
        args.push("--audio-format", options.format);
      }
    } else if (options.quality) {
      let formatSelector: string | null = null;

      if (videoInfo?.qualityOptions) {
        const qualityOption = videoInfo.qualityOptions.find(
          (opt) => opt.key === options.quality,
        );
        if (qualityOption) {
          const height = qualityOption.videoFormat
            ? this.getHeightFromFormat(qualityOption.videoFormat)
            : null;
          const videoId = qualityOption.videoFormat?.formatId;
          const audioId = qualityOption.audioFormat?.formatId || "bestaudio";

          if (qualityOption.key === "bestaudio") {
            formatSelector = "bestaudio/best";
          } else if (height) {
            // User requirement: prevent jumping to higher quality
            formatSelector = `${videoId}+${audioId}/bestvideo[height<=${height}]+bestaudio/best[height<=${height}]`;
            args.push("--format-sort", `res:${height},vcodec:h264,acodec:m4a`);
          } else {
            formatSelector = `${videoId}+${audioId}/bestvideo+bestaudio/best`;
            args.push("--format-sort", "res,vcodec:h264,acodec:m4a");
          }
        }
      }

      if (!formatSelector) {
        const qualityMap: Record<string, string> = {
          [DownloadQuality.BEST_VIDEO]: "bestvideo+bestaudio/best",
          [DownloadQuality.QUALITY_4K]:
            "bestvideo[height<=2160]+bestaudio/best[height<=2160]",
          [DownloadQuality.QUALITY_1440P]:
            "bestvideo[height<=1440]+bestaudio/best[height<=1440]",
          [DownloadQuality.QUALITY_1080P]:
            "bestvideo[height<=1080]+bestaudio/best[height<=1080]",
          [DownloadQuality.QUALITY_720P]:
            "bestvideo[height<=720]+bestaudio/best[height<=720]",
          [DownloadQuality.QUALITY_480P]:
            "bestvideo[height<=480]+bestaudio/best[height<=480]",
          [DownloadQuality.QUALITY_360P]:
            "bestvideo[height<=360]+bestaudio/best[height<=360]",
          [DownloadQuality.AUDIO_ONLY]: "bestaudio/best",
        };
        formatSelector = qualityMap[options.quality] || options.quality;
        const resMatch = options.quality.match(/(\d+)p/);
        if (resMatch) {
          args.push(
            "--format-sort",
            `res:${resMatch[1]},vcodec:h264,acodec:m4a`,
          );
        }
      }
      args.push("-f", formatSelector);
    } else {
      // Default to best quality if no specific quality is requested
      args.push("-f", "bestvideo+bestaudio/best");
    }

    // Merging logic
    if (!options.audioOnly) {
      const outputFormat = options.format || "mp4";
      args.push("--merge-output-format", outputFormat);
      args.push("--no-keep-video");
      if (outputFormat === "mp4") {
        args.push("--postprocessor-args", "ffmpeg:-c:v copy -c:a aac");
      } else {
        args.push("--postprocessor-args", "ffmpeg:-c copy");
      }
    }

    // Subtitles, Thumbnails, Metadata, etc.
    if (options.subtitles?.download) {
      args.push("--write-subs");
      if (options.subtitles.languages?.length) {
        args.push("--sub-langs", options.subtitles.languages.join(","));
      } else {
        args.push("--sub-langs", "all");
      }
      if (options.subtitles.embedInVideo) args.push("--embed-subs");
    }

    if (options.thumbnail?.download) {
      args.push("--write-thumbnail");
      if (options.thumbnail.embedInVideo) args.push("--embed-thumbnail");
    }

    if (options.metadata?.embedInVideo) {
      args.push("--embed-metadata");
      args.push("--add-metadata");
    }

    if (options.verbose) {
      args.push("--verbose");
    }

    if (options.rateLimit) args.push("-r", options.rateLimit);
    if (options.proxy) args.push("--proxy", options.proxy);
    if (options.cookies) args.push("--cookies", options.cookies);

    args.push(options.url);
    return args;
  }

  private getHeightFromFormat(format: VideoFormat): number | null {
    if (format.resolution) {
      const pMatch = format.resolution.match(/(\d+)p/);
      if (pMatch) return parseInt(pMatch[1]);
      const wxhMatch = format.resolution.match(/(\d+)x(\d+)/);
      if (wxhMatch) return parseInt(wxhMatch[2]);
    }
    if (format.quality) {
      const match = String(format.quality).match(/(\d+)p/);
      if (match) return parseInt(match[1]);
    }
    return null;
  }
}
